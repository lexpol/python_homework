# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (add()),
# вычитание (sub()), умножение (mul()), деление (truediv()). Данные методы должны применяться только к клеткам и
# выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
#
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше
# нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и
# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    cell_numbers: int

    def __init__(self, cell_numbers: int):
        self.cell_numbers = cell_numbers

    def __add__(self, other):
        return self.cell_numbers + other.cell_numbers

    def __sub__(self, other):
        if self.cell_numbers < other.cell_numbers:
            return f"вычитание невозможно, вычитаемая клетка сильно большая!"
        elif self.cell_numbers == other.cell_numbers:
            return f"в результате вычитания клетки аннигилировали!"
        elif self.cell_numbers > other.cell_numbers:
            return self.cell_numbers - other.cell_numbers

    def __mul__(self, other):
        return self.cell_numbers * other.cell_numbers

    def __truediv__(self, other):
        return self.cell_numbers // other.cell_numbers

    def make_order(self, cell_in_line):
        rows = self.cell_numbers // cell_in_line
        rest = self.cell_numbers % cell_in_line
        for i in range(rows):
            print("*" * cell_in_line)
        print(f"*" * rest)
        print()



ameba = Cell(1)
bacteria = Cell(15)
yeast = Cell(222)

print(ameba + bacteria)
print(ameba - bacteria)
print(bacteria - ameba)
print(ameba * bacteria)
print(bacteria * yeast)
print(yeast / bacteria)

bacteria.make_order(8)
yeast.make_order(44)